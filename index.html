<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pokemon VR - Final Polish</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="style.css" />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.js"
      crossorigin="anonymous"
    ></script>
  </head>

  <body>
    <script type="module">
      import { VRButton } from "https://unpkg.com/three@0.126.0/examples/jsm/webxr/VRButton.js";
      import { FBXLoader } from "https://unpkg.com/three@0.126.0/examples/jsm/loaders/FBXLoader.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.126.0/examples/jsm/loaders/GLTFLoader.js";
      import { XRControllerModelFactory } from "https://unpkg.com/three@0.126.0/examples/jsm/webxr/XRControllerModelFactory.js";

      let currentPokeball = null;

      let camera, scene, renderer;
      let controllerL, controllerR;

      let userDolly;
      let rightGamepad = null;
      let leftGamepad = null;

      let pokeballs = [];
      const POKEBALL_SPEED = 0.3;
      const clock = new THREE.Clock();

      let captureTargets = [];
      let mario, pikachu, trex, snorlax;
      let capturingTargets = [];

      let trexMixer;
      let isTrexCaptured = false;

      let pokeballClosedModel = null;
      let pokeballOpenModel = null;

      // Score Variables
      let score = 0;
      let totalTargets = 0;
      let scoreSprite = null;

      const LIFE_COLORS = [0xff0000, 0xffa500, 0xffff00, 0xadff2f, 0x00ff00];

      initConfiguration();
      initScene();

      function initConfiguration() {
        const container = document.createElement("div");
        document.body.appendChild(container);

        let textureLoader = new THREE.TextureLoader();

        scene = new THREE.Scene();

        const textureSky = textureLoader.load(
          "https://cdn.polyhaven.com/asset_img/primary/qwantani_noon_puresky.png?height=760&quality=95"
        );
        const materialSky = new THREE.MeshBasicMaterial({
          map: textureSky,
          side: THREE.DoubleSide,
        });
        const sky = new THREE.Mesh(
          new THREE.SphereGeometry(30, 32, 32),
          materialSky
        );
        scene.add(sky);

        const textureGround = textureLoader.load(
          "models/grass.jpg",
          function (texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(60, 60);
          }
        );
        const materialGround = new THREE.MeshStandardMaterial({
          map: textureGround,
        });
        let plane = new THREE.Mesh(
          new THREE.PlaneGeometry(60, 60),
          materialGround
        );
        plane.rotation.set(-3.14159 / 2, 0, 0);
        plane.receiveShadow = true;
        scene.add(plane);

        userDolly = new THREE.Group();
        userDolly.position.set(0, 0, 8);
        scene.add(userDolly);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          40
        );
        camera.position.set(0, 1.6, 0);
        userDolly.add(camera);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        var controllerModelFactory = new XRControllerModelFactory();

        // Right Controller
        controllerR = renderer.xr.getControllerGrip(0);
        const modelR = controllerModelFactory.createControllerModel(
          controllerR,
          new THREE.MeshPhongMaterial({
            shininess: 6,
            shading: true,
            opacity: 0.8,
            transparent: true,
          })
        );
        controllerR.add(modelR);
        userDolly.add(controllerR);

        // Left Controller (Holds Score)
        controllerL = renderer.xr.getControllerGrip(1);
        const modelL =
          controllerModelFactory.createControllerModel(controllerL);
        controllerL.add(modelL);
        userDolly.add(controllerL);

        // Setup Scoreboard on Left Hand
        createScoreBoard();

        const controllerRightInput = renderer.xr.getController(0);
        controllerRightInput.addEventListener("connected", (event) => {
          if (event.data.gamepad) rightGamepad = event.data.gamepad;
        });

        const controllerLeftInput = renderer.xr.getController(1);
        controllerLeftInput.addEventListener("connected", (event) => {
          if (event.data.gamepad) leftGamepad = event.data.gamepad;
        });

        controllerR.addEventListener("selectstart", ThrowPokeball);
        controllerR.addEventListener("squeezestart", SpawnPokeball);

        const pokeballLoader = new GLTFLoader();

        pokeballLoader.load("models/pokeball-closed.glb", (gltf) => {
          pokeballClosedModel = gltf.scene;
        });

        pokeballLoader.load("models/pokeball-open.glb", (gltf) => {
          pokeballOpenModel = gltf.scene;
        });

        // Trees
        new FBXLoader().load("models/Tree.fbx", (object) => {
          object.traverse((child) => {
            object.scale.set(0.004, 0.004, 0.004);
            createTree(object.clone(), [0, 0, -10]);
            createTree(object.clone(), [5, 0, -3]);
            createTree(object.clone(), [5, 0, 6]);
            createTree(object.clone(), [15, 0, -20]);
            createTree(object.clone(), [7, 0, 13]);
            createTree(object.clone(), [0, 0, 10]);
            createTree(object.clone(), [-5, 0, 3]);
            createTree(object.clone(), [-5, 0, -6]);
            createTree(object.clone(), [-15, 0, 20]);
            createTree(object.clone(), [10, 0, -8]);
            createTree(object.clone(), [-10, 0, -12]);
            createTree(object.clone(), [8, 0, 15]);
            createTree(object.clone(), [-12, 0, 8]);
            createTree(object.clone(), [18, 0, 5]);
            createTree(object.clone(), [-8, 0, -15]);
            createTree(object.clone(), [3, 0, -18]);
          });
        });

        function createTree(tree, position) {
          tree.position.set(position[0], position[1], position[2]);
          scene.add(tree);
        }

        // Pokemon Loaders
        const marioLoader = new GLTFLoader();
        marioLoader.load("models/mario_obj.glb", (gltf) => {
          mario = gltf.scene;
          mario.name = "Mario";
          mario.scale.set(0.3, 0.3, 0.3);
          mario.position.set(0, 0, -3);

          mario.updateMatrixWorld();
          mario.userData.boundingBox = new THREE.Box3().setFromObject(mario);

          createLifeBar(mario);
          scene.add(mario);
          captureTargets.push(mario);
          updateTotalTargets();
        });

        const pikaLoader = new GLTFLoader();
        pikaLoader.load("models/pikachu.glb", (gltf) => {
          pikachu = gltf.scene;
          pikachu.name = "Pikachu";
          pikachu.scale.set(0.3, 0.3, 0.3);
          pikachu.position.set(0, 0, 3);

          pikachu.updateMatrixWorld();
          pikachu.userData.boundingBox = new THREE.Box3().setFromObject(
            pikachu
          );

          createLifeBar(pikachu);
          scene.add(pikachu);
          captureTargets.push(pikachu);
          updateTotalTargets();
        });

        const snorlaxLoader = new GLTFLoader();
        snorlaxLoader.load("models/snorlax.glb", (gltf) => {
          snorlax = gltf.scene;
          snorlax.name = "Snorlax";
          snorlax.scale.set(0.5, 0.5, 0.5);
          snorlax.position.set(4, 0, 0);

          snorlax.updateMatrixWorld();
          snorlax.userData.boundingBox = new THREE.Box3().setFromObject(
            snorlax
          );

          createLifeBar(snorlax);
          scene.add(snorlax);
          captureTargets.push(snorlax);
          updateTotalTargets();
        });

        const rexLoader = new GLTFLoader();
        rexLoader.load("models/animated_rexy.glb", (gltf) => {
          trex = gltf.scene;
          trex.name = "T-Rex";
          trex.scale.set(2, 2, 2);
          trex.position.set(-5, 0, -4);

          trex.updateMatrixWorld();
          trex.userData.boundingBox = new THREE.Box3().setFromObject(trex);

          createLifeBar(trex);
          scene.add(trex);
          captureTargets.push(trex);
          updateTotalTargets();

          if (gltf.animations && gltf.animations.length > 0) {
            trexMixer = new THREE.AnimationMixer(trex);
            const action = trexMixer.clipAction(gltf.animations[0]);
            action.play();
          }
        });

        window.updateTrexMixer = function (delta) {
          if (trexMixer && !isTrexCaptured) trexMixer.update(delta);
        };

        renderer.xr.enabled = true;
        container.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));
        renderer.setAnimationLoop(render);
      }

      function initScene() {
        var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);
      }

      function updateTotalTargets() {
        totalTargets = captureTargets.length;
        updateScoreDisplay();
      }

      // --- WIDE CANVAS TEXT SPRITE (No Clipping) ---
      function makeTextSprite(message, parameters) {
        if (parameters === undefined) parameters = {};

        var fontface = parameters.hasOwnProperty("fontface")
          ? parameters["fontface"]
          : "Arial Black";
        var fontsize = parameters.hasOwnProperty("fontsize")
          ? parameters["fontsize"]
          : 60;
        var borderThickness = parameters.hasOwnProperty("borderThickness")
          ? parameters["borderThickness"]
          : 4;
        var borderColor = parameters.hasOwnProperty("borderColor")
          ? parameters["borderColor"]
          : { r: 0, g: 0, b: 0, a: 1.0 };
        var backgroundColor = parameters.hasOwnProperty("backgroundColor")
          ? parameters["backgroundColor"]
          : { r: 0, g: 0, b: 0, a: 0.4 };
        var textColor = parameters.hasOwnProperty("textColor")
          ? parameters["textColor"]
          : { r: 255, g: 255, b: 255, a: 1.0 };

        var canvas = document.createElement("canvas");
        // FIX: Increased canvas width to 2048 to prevent left/right clipping
        canvas.width = 2048;
        canvas.height = 512;
        var context = canvas.getContext("2d");

        context.font = fontsize + "px " + fontface;

        var metrics = context.measureText(message);
        var textWidth = metrics.width;

        const xPos = canvas.width / 2;
        const yPos = canvas.height / 2;

        if (backgroundColor.a > 0) {
          context.fillStyle =
            "rgba(" +
            backgroundColor.r +
            "," +
            backgroundColor.g +
            "," +
            backgroundColor.b +
            "," +
            backgroundColor.a +
            ")";
          const padding = 30; // More padding
          context.fillRect(
            xPos - textWidth / 2 - padding,
            yPos - fontsize / 2 - padding,
            textWidth + padding * 2,
            fontsize + padding * 2
          );
        }

        context.textAlign = "center";
        context.textBaseline = "middle";

        context.strokeStyle =
          "rgba(" +
          borderColor.r +
          "," +
          borderColor.g +
          "," +
          borderColor.b +
          "," +
          borderColor.a +
          ")";
        context.lineWidth = borderThickness;
        context.fillStyle =
          "rgba(" +
          textColor.r +
          ", " +
          textColor.g +
          ", " +
          textColor.b +
          ", 1.0)";

        context.strokeText(message, xPos, yPos);
        context.fillText(message, xPos, yPos);

        var texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        texture.minFilter = THREE.LinearFilter;

        var spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
        });
        var sprite = new THREE.Sprite(spriteMaterial);
        // Maintain Aspect Ratio based on new wide canvas
        sprite.scale.set(canvas.width / canvas.height, 1, 1);
        return sprite;
      }

      // --- SCOREBOARD ---
      function createScoreBoard() {
        scoreSprite = makeTextSprite("Score: 0 / 0");
        // FIX: Moved slightly right (0.1) and ensured scale fits new aspect ratio
        scoreSprite.position.set(0.1, 0.2, 0);
        scoreSprite.scale.multiplyScalar(0.08); // Smaller multiplier because base canvas is huge now
        controllerL.add(scoreSprite);
      }

      function updateScoreDisplay() {
        if (!scoreSprite) return;
        const sprite = makeTextSprite(`Score: ${score} / ${totalTargets}`);
        scoreSprite.material.map = sprite.material.map;
        scoreSprite.material.needsUpdate = true;
      }

      // --- LIFE BARS & STATUS TEXT ---
      function createLifeBar(model) {
        model.userData.life = 5;
        model.userData.lifeSlots = [];

        const lifeGroup = new THREE.Group();

        const box = new THREE.Box3().setFromObject(model);
        let localHeadTop = (box.max.y - model.position.y) / model.scale.y;

        let paddingOffset = 0.5;
        if (model.name === "T-Rex") paddingOffset += 2.5;

        const verticalPos = localHeadTop + paddingOffset / model.scale.y;
        lifeGroup.position.y = verticalPos;

        const inverseScale = 1.0 / model.scale.y;
        lifeGroup.scale.set(inverseScale, inverseScale, inverseScale);

        const geometry = new THREE.BoxGeometry(0.22, 0.15, 0.08);
        const initialColor = new THREE.Color(LIFE_COLORS[4]);

        for (let i = 0; i < 5; i++) {
          const material = new THREE.MeshBasicMaterial({ color: initialColor });
          const slot = new THREE.Mesh(geometry, material);
          slot.position.x = (i - 2) * 0.25;
          lifeGroup.add(slot);
          model.userData.lifeSlots.push(slot);
        }

        model.userData.lifeGroup = lifeGroup;
        model.add(lifeGroup);

        const catchSprite = makeTextSprite("Catch it NOW!", {
          fontsize: 80,
          fontface: "Arial Black",
          textColor: { r: 255, g: 255, b: 255, a: 1.0 },
          borderColor: { r: 0, g: 0, b: 0, a: 1.0 },
          borderThickness: 8,
          backgroundColor: { r: 0, g: 0, b: 0, a: 0.5 },
        });

        catchSprite.position.y = verticalPos;
        // Adjusted scale to handle the 2048 width canvas
        // 4:1 ratio (2048/512)
        catchSprite.scale.set(inverseScale * 4.0, inverseScale * 1.0, 1.0);
        catchSprite.visible = false;

        model.userData.catchSprite = catchSprite;
        model.add(catchSprite);
      }

      function checkPokeballCollisions() {
        for (let i = pokeballs.length - 1; i >= 0; i--) {
          const ball = pokeballs[i];
          const ballSphere = new THREE.Sphere(ball.position, 0.2);

          for (let j = 0; j < captureTargets.length; j++) {
            const target = captureTargets[j];
            if (!target) continue;

            if (target.userData.boundingBox)
              target.userData.boundingBox.setFromObject(target);

            if (target.userData.boundingBox.intersectsSphere(ballSphere)) {
              console.log("COLLISION CONFIRMED WITH: ", target.name);
              const collisionPosition = ball.position.clone();
              scene.remove(ball);
              pokeballs.splice(i, 1);

              if (target.userData.life > 0) {
                target.userData.life -= 1;
                const currentLife = target.userData.life;

                if (currentLife === 0) {
                  if (target.userData.lifeGroup)
                    target.userData.lifeGroup.visible = false;
                  if (target.userData.catchSprite)
                    target.userData.catchSprite.visible = true;
                } else {
                  if (target.userData.lifeSlots[currentLife]) {
                    target.userData.lifeSlots[currentLife].visible = false;
                  }
                  if (currentLife > 0) {
                    const newColorHex = LIFE_COLORS[currentLife - 1];
                    const newColor = new THREE.Color(newColorHex);
                    for (let k = 0; k < currentLife; k++) {
                      target.userData.lifeSlots[k].material.color.copy(
                        newColor
                      );
                    }
                  }
                }
              } else {
                captureTarget(target, collisionPosition);
              }
              break;
            }
          }
        }
      }

      function captureTarget(target, collisionPosition) {
        if (target.userData.boxHelper) {
          scene.remove(target.userData.boxHelper);
          target.userData.boxHelper = null;
        }

        if (target.userData.lifeGroup)
          target.userData.lifeGroup.visible = false;
        if (target.userData.catchSprite)
          target.userData.catchSprite.visible = false;

        if (target.name === "T-Rex") isTrexCaptured = true;

        target.userData.capturing = true;
        target.userData.captureProgress = 0;

        score++;
        updateScoreDisplay();

        target.userData.initialScale = {
          x: target.scale.x,
          y: target.scale.y,
          z: target.scale.z,
        };
        target.userData.initialY = target.position.y;

        if (pokeballOpenModel) {
          const openBall = pokeballOpenModel.clone();
          openBall.position.set(target.position.x, 0.25, target.position.z);
          openBall.scale.set(0.015, 0.015, 0.015);
          scene.add(openBall);
          target.userData.openPokeball = openBall;
        }

        capturingTargets.push(target);
      }

      function updateCaptures() {
        for (let i = capturingTargets.length - 1; i >= 0; i--) {
          const target = capturingTargets[i];

          target.userData.captureProgress += 0.02;
          const progress = target.userData.captureProgress;

          if (progress < 1.0) {
            target.rotation.y += 0.3;
            const scaleMultiplier = 1 - progress;
            target.scale.set(
              target.userData.initialScale.x * scaleMultiplier,
              target.userData.initialScale.y * scaleMultiplier,
              target.userData.initialScale.z * scaleMultiplier
            );
            target.position.y = THREE.MathUtils.lerp(
              target.userData.initialY,
              0.25,
              progress
            );
          } else {
            console.log(`${target.name} captured!`);
            scene.remove(target);
            if (target.userData.openPokeball)
              scene.remove(target.userData.openPokeball);
            capturingTargets.splice(i, 1);
            const index = captureTargets.indexOf(target);
            if (index > -1) captureTargets.splice(index, 1);
          }
        }
      }

      function SpawnPokeball(event) {
        if (!currentPokeball && pokeballClosedModel) {
          currentPokeball = pokeballClosedModel.clone();
          currentPokeball.scale.set(0.03, 0.03, 0.03);
          controllerR.add(currentPokeball);
        }
      }

      function ThrowPokeball(event) {
        if (currentPokeball) {
          scene.attach(currentPokeball);
          const pokeball = currentPokeball;
          pokeball.scale.set(0.08, 0.08, 0.08);

          const direction = new THREE.Vector3(0, -0.3, -1);
          const worldQuaternion = new THREE.Quaternion();
          controllerR.getWorldQuaternion(worldQuaternion);
          direction.applyQuaternion(worldQuaternion);
          direction.normalize();

          pokeball.userData.velocity = direction.multiplyScalar(POKEBALL_SPEED);
          pokeball.userData.lifetime = 0;

          pokeballs.push(pokeball);
          currentPokeball = null;
        }
      }

      function updatePokeballs() {
        for (let i = pokeballs.length - 1; i >= 0; i--) {
          const ball = pokeballs[i];
          ball.position.add(ball.userData.velocity);
          ball.userData.velocity.y -= 0.01;
          ball.userData.lifetime++;
          if (ball.position.y < 0 || ball.userData.lifetime > 300) {
            scene.remove(ball);
            pokeballs.splice(i, 1);
          }
        }
      }

      function handleControllerInput() {
        if (rightGamepad) {
          const axisX = rightGamepad.axes[2];
          if (Math.abs(axisX) > 0.1) userDolly.rotation.y -= axisX * 0.04;
        }

        if (leftGamepad) {
          const axisY = leftGamepad.axes[3];
          if (Math.abs(axisY) > 0.1) userDolly.translateZ(axisY * 0.1);
        }
      }

      function updateModelMovements() {
        const time = clock.getElapsedTime();
        const playerPos = new THREE.Vector3();
        camera.getWorldPosition(playerPos);

        const updateStatusRotation = (model) => {
          if (model.userData.lifeGroup)
            model.userData.lifeGroup.lookAt(playerPos);
        };

        if (pikachu && !pikachu.userData.capturing) {
          const lookAheadT = time + 0.1;
          const targetX = Math.sin(lookAheadT * 2.0) * 5;
          const targetZ = Math.sin(lookAheadT * 4.0) * 2.5;
          pikachu.lookAt(targetX, pikachu.position.y, targetZ);
          pikachu.position.x = Math.sin(time * 2.0) * 5;
          pikachu.position.z = Math.sin(time * 4.0) * 2.5;
          updateStatusRotation(pikachu);
        }

        if (snorlax && !snorlax.userData.capturing) {
          const centerX = 4;
          const centerZ = 0;
          const radius = 6;
          const speed = 0.3;
          const lookAheadT = time + 0.2;
          const targetX = centerX + Math.cos(lookAheadT * speed) * radius;
          const targetZ = centerZ + Math.sin(lookAheadT * speed) * radius;
          snorlax.lookAt(targetX, snorlax.position.y, targetZ);
          snorlax.rotation.y -= Math.PI / 2;
          snorlax.position.x = centerX + Math.cos(time * speed) * radius;
          snorlax.position.z = centerZ + Math.sin(time * speed) * radius;
          updateStatusRotation(snorlax);
        }

        if (trex && !trex.userData.capturing) {
          const centerX = -5;
          const centerZ = 0;
          const widthX = 4;
          const depthZ = 10;
          const speed = 0.5;
          const lookAheadT = time + 0.1;
          const targetX = centerX + Math.cos(lookAheadT * speed) * widthX;
          const targetZ = centerZ + Math.sin(lookAheadT * speed) * depthZ;
          trex.lookAt(targetX, trex.position.y, targetZ);
          trex.position.x = centerX + Math.cos(time * speed) * widthX;
          trex.position.z = centerZ + Math.sin(time * speed) * depthZ;
          updateStatusRotation(trex);
        }

        if (mario && !mario.userData.capturing) updateStatusRotation(mario);
      }

      function render() {
        const delta = clock.getDelta();
        if (window.updateTrexMixer) window.updateTrexMixer(delta);

        handleControllerInput();
        updateModelMovements();
        updatePokeballs();
        checkPokeballCollisions();
        updateCaptures();
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
